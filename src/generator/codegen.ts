import type { OpenAPIV3 } from 'openapi-types';
import { ParsedAPI, ParsedOperation, GeneratedFunction } from './types';

/**
 * Generate TypeScript code from parsed OpenAPI document
 */
export function generateTypeScriptCode(parsedAPI: ParsedAPI, baseURL?: string): string {
  const { info, servers, operations } = parsedAPI;
  const defaultBaseURL = baseURL || servers?.[0]?.url || '';

  let code = `/**
 * Generated by react-api-weaver
 * ${info.title} - ${info.version}
 * ${info.description || ''}
 * Do not edit manually
 */

import { makeRequest } from 'react-api-weaver';
import type { RequestConfig } from 'react-api-weaver';

const BASE_URL = '${defaultBaseURL}';

`;

  // Generate interfaces and functions for each operation
  for (const operation of operations) {
    const generatedFunc = generateFunctionFromOperation(operation);
    
    // Add parameter interface if exists
    if (generatedFunc.paramsInterface) {
      code += generatedFunc.paramsInterface + '\n\n';
    }

    // Add body interface if exists
    if (generatedFunc.bodyInterface) {
      code += generatedFunc.bodyInterface + '\n\n';
    }

    // Add response interface if exists
    if (generatedFunc.returnInterface) {
      code += generatedFunc.returnInterface + '\n\n';
    }

    // Add function
    code += generateFunctionCode(generatedFunc) + '\n\n';
  }

  return code;
}

/**
 * Generate JavaScript code from parsed OpenAPI document
 */
export function generateJavaScriptCode(parsedAPI: ParsedAPI, baseURL?: string): string {
  const { info, servers, operations } = parsedAPI;
  const defaultBaseURL = baseURL || servers?.[0]?.url || '';

  let code = `/**
 * Generated by react-api-weaver
 * ${info.title} - ${info.version}
 * ${info.description || ''}
 * Do not edit manually
 */

import { makeRequest } from 'react-api-weaver';

const BASE_URL = '${defaultBaseURL}';

`;

  // Generate functions for each operation (without types)
  for (const operation of operations) {
    const generatedFunc = generateFunctionFromOperation(operation);
    code += generateJavaScriptFunctionCode(generatedFunc) + '\n\n';
  }

  return code;
}

/**
 * Generate function metadata from operation
 */
function generateFunctionFromOperation(operation: ParsedOperation): GeneratedFunction {
  const functionName = toCamelCase(operation.operationId);
  
  // Parse parameters
  const hasParams = operation.parameters && operation.parameters.length > 0;
  const paramsTypeName = hasParams ? `${toPascalCase(functionName)}Params` : undefined;
  const paramsInterface = hasParams
    ? generateParamsInterface(paramsTypeName!, operation.parameters!)
    : undefined;

  // Parse request body
  const hasBody = !!operation.requestBody;
  const bodyTypeName = hasBody ? `${toPascalCase(functionName)}Body` : undefined;
  const bodyInterface = hasBody
    ? generateBodyInterface(bodyTypeName!, operation.requestBody!)
    : undefined;

  // Parse response
  const returnTypeName = `${toPascalCase(functionName)}Response`;
  const returnInterface = generateResponseInterface(returnTypeName, operation.responses);

  return {
    name: functionName,
    method: operation.method,
    path: operation.path,
    description: operation.description || operation.summary,
    paramsType: paramsTypeName,
    paramsInterface,
    bodyType: bodyTypeName,
    bodyInterface,
    returnType: returnTypeName,
    returnInterface,
  };
}

/**
 * Generate TypeScript interface for parameters
 */
function generateParamsInterface(
  typeName: string,
  parameters: OpenAPIV3.ParameterObject[]
): string {
  let code = `export interface ${typeName} {\n`;

  for (const param of parameters) {
    const optional = !param.required ? '?' : '';
    const type = getTypeFromSchema(param.schema);
    const description = param.description ? `  /** ${param.description} */\n` : '';
    
    code += `${description}  ${param.name}${optional}: ${type};\n`;
  }

  code += '}';
  return code;
}

/**
 * Generate TypeScript interface for request body
 */
function generateBodyInterface(
  typeName: string,
  requestBody: OpenAPIV3.RequestBodyObject
): string {
  const content = requestBody.content?.['application/json'];
  if (!content?.schema) {
    return `export type ${typeName} = any;`;
  }

  const schema = content.schema as OpenAPIV3.SchemaObject;

  if (schema.type === 'object' && schema.properties) {
    let code = `export interface ${typeName} {\n`;
    
    for (const [propName, propSchema] of Object.entries(schema.properties)) {
      const prop = propSchema as OpenAPIV3.SchemaObject;
      const optional = !schema.required?.includes(propName) ? '?' : '';
      const type = getTypeFromSchema(prop);
      const description = prop.description ? `  /** ${prop.description} */\n` : '';
      
      code += `${description}  ${propName}${optional}: ${type};\n`;
    }
    
    code += '}';
    return code;
  }

  const type = getTypeFromSchema(schema);
  return `export type ${typeName} = ${type};`;
}

/**
 * Generate TypeScript interface for response
 */
function generateResponseInterface(
  typeName: string,
  responses: OpenAPIV3.ResponsesObject
): string {
  // Look for successful response (200, 201, etc.)
  const successResponse = responses['200'] || responses['201'] || responses['204'];
  
  if (!successResponse) {
    return `export type ${typeName} = any;`;
  }

  const response = successResponse as OpenAPIV3.ResponseObject;
  const content = response.content?.['application/json'];
  
  if (!content?.schema) {
    return `export type ${typeName} = void;`;
  }

  const schema = content.schema as OpenAPIV3.SchemaObject;

  if (schema.type === 'object' && schema.properties) {
    let code = `export interface ${typeName} {\n`;
    
    for (const [propName, propSchema] of Object.entries(schema.properties)) {
      const prop = propSchema as OpenAPIV3.SchemaObject;
      const optional = !schema.required?.includes(propName) ? '?' : '';
      const type = getTypeFromSchema(prop);
      const description = prop.description ? `  /** ${prop.description} */\n` : '';
      
      code += `${description}  ${propName}${optional}: ${type};\n`;
    }
    
    code += '}';
    return code;
  }

  const type = getTypeFromSchema(schema);
  return `export type ${typeName} = ${type};`;
}

/**
 * Get TypeScript type from OpenAPI schema
 */
function getTypeFromSchema(schema: any): string {
  if (!schema) return 'any';

  if (schema.type === 'array') {
    const itemType = getTypeFromSchema(schema.items);
    return `${itemType}[]`;
  }

  switch (schema.type) {
    case 'string':
      return schema.enum ? schema.enum.map((v: string) => `'${v}'`).join(' | ') : 'string';
    case 'number':
    case 'integer':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'object':
      return 'Record<string, any>';
    default:
      return 'any';
  }
}

/**
 * Generate TypeScript function code
 */
function generateFunctionCode(func: GeneratedFunction): string {
  const { name, method, path, description, paramsType, bodyType, returnType } = func;

  const descComment = description ? `/**\n * ${description}\n */\n` : '';
  
  // Build function signature
  const params: string[] = [];
  
  if (paramsType) {
    params.push(`params: ${paramsType}`);
  } else if (method === 'GET') {
    params.push('params?: Record<string, any>');
  }
  
  if (bodyType) {
    params.push(`body: ${bodyType}`);
  } else if (['POST', 'PUT', 'PATCH'].includes(method)) {
    params.push('body?: any');
  }
  
  params.push('config?: RequestConfig');
  
  const paramString = params.join(', ');

  // Build function body
  const pathWithParams = path.replace(/\{([^}]+)\}/g, (_, param) => `\${params.${param}}`);
  
  let functionBody = `  return makeRequest<${returnType}>({\n`;
  functionBody += `    method: '${method}',\n`;
  functionBody += `    url: \`${pathWithParams}\`,\n`;
  
  if (method === 'GET') {
    functionBody += `    params,\n`;
  } else if (['POST', 'PUT', 'PATCH'].includes(method)) {
    functionBody += `    body,\n`;
  }
  
  functionBody += `    baseURL: BASE_URL,\n`;
  functionBody += `    ...config,\n`;
  functionBody += `  });\n`;

  return `${descComment}export async function ${name}(${paramString}): Promise<${returnType}> {\n${functionBody}}`;
}

/**
 * Generate JavaScript function code
 */
function generateJavaScriptFunctionCode(func: GeneratedFunction): string {
  const { name, method, path, description } = func;

  const descComment = description ? `/**\n * ${description}\n */\n` : '';
  
  // Build function signature
  const params: string[] = [];
  
  if (method === 'GET') {
    params.push('params');
  } else if (['POST', 'PUT', 'PATCH'].includes(method)) {
    params.push('params', 'body');
  }
  
  params.push('config');
  
  const paramString = params.join(', ');

  // Build function body
  const pathWithParams = path.replace(/\{([^}]+)\}/g, (_, param) => `\${params?.${param}}`);
  
  let functionBody = `  return makeRequest({\n`;
  functionBody += `    method: '${method}',\n`;
  functionBody += `    url: \`${pathWithParams}\`,\n`;
  
  if (method === 'GET') {
    functionBody += `    params,\n`;
  } else if (['POST', 'PUT', 'PATCH'].includes(method)) {
    functionBody += `    body,\n`;
  }
  
  functionBody += `    baseURL: BASE_URL,\n`;
  functionBody += `    ...config,\n`;
  functionBody += `  });\n`;

  return `${descComment}export async function ${name}(${paramString}) {\n${functionBody}}`;
}

/**
 * Convert string to camelCase
 */
function toCamelCase(str: string): string {
  const pascal = toPascalCase(str);
  return pascal.charAt(0).toLowerCase() + pascal.slice(1);
}

/**
 * Convert string to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .replace(/[^a-zA-Z0-9]+(.)/g, (_, chr) => chr.toUpperCase())
    .replace(/^[a-z]/, (chr) => chr.toUpperCase());
}

